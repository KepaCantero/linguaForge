"use client";

import { useState, useCallback, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Phrase, ClozeOption, ConversationalBlock } from "@/types";
import { useGamificationStore } from "@/store/useGamificationStore";
import { useTTS } from "@/services/ttsService";
import { XP_RULES } from "@/lib/constants";
import { useSoundEffects, useSoundEffectsInit } from "@/hooks/useSoundEffects";

interface ClozeExerciseProps {
  phrase: Phrase;
  block?: ConversationalBlock; // Bloque completo para contexto
  onComplete: (correct: boolean) => void;
}

export function ClozeExercise({ phrase, block, onComplete }: ClozeExerciseProps) {

  const { addXP } = useGamificationStore();
  const { speak, isSpeaking } = useTTS();
  const { play, playCorrect, playIncorrect, enabled: soundEnabled } = useSoundEffects();

  // Inicializar efectos de sonido tras primera interacci√≥n
  useSoundEffectsInit();

  const [selectedOption, setSelectedOption] = useState<ClozeOption | null>(
    null
  );
  const [showResult, setShowResult] = useState(false);
  const [isCorrect, setIsCorrect] = useState(false);
  const [showTranslation, setShowTranslation] = useState(false);

  // Si hay un bloque, mostrar todas las frases del bloque con contexto
  const phrasesToShow = block?.phrases || [phrase];

  // Crear texto con hueco solo para la frase actual
  const textWithGap = phrase.text.replace(phrase.clozeWord, "______");

  // Texto completo del bloque para reproducir
  const fullBlockText = block
    ? block.phrases.map(p => p.text).join(" ")
    : phrase.text;


  // Reproducir la frase completa o el bloque completo con TTS
  const playPhrase = useCallback(() => {
    speak(fullBlockText);
  }, [speak, fullBlockText]);

  const handleOptionSelect = useCallback(
    (option: ClozeOption) => {
      if (showResult) return;

      // Feedback h√°ptico en m√≥viles
      if (typeof navigator !== "undefined" && "vibrate" in navigator) {
        navigator.vibrate(10);
      }

      // Sonido de click
      if (soundEnabled) {
        play('click');
      }

      setSelectedOption(option);
      setIsCorrect(option.isCorrect);
      setShowResult(true);

      // Sonido de respuesta correcta/incorrecta
      if (soundEnabled) {
        if (option.isCorrect) {
          playCorrect();
        } else {
          playIncorrect();
        }
      }

      // Dar XP
      addXP(option.isCorrect ? XP_RULES.clozeCorrect : XP_RULES.clozeIncorrect);

      // Esperar antes de continuar (estandarizado a 2s)
      setTimeout(() => {
        onComplete(option.isCorrect);
      }, 2000);
    },
    [showResult, addXP, onComplete, soundEnabled, play, playCorrect, playIncorrect]
  );

  // Atajos de teclado: 1-4 para seleccionar opci√≥n, ESPACIO para reproducir audio
  useEffect(() => {
    if (showResult) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      // ESPACIO para reproducir audio
      if (e.key === " " && !isSpeaking) {
        e.preventDefault();
        playPhrase();
        return;
      }

      // 1-4 para seleccionar opci√≥n
      const keyNum = parseInt(e.key);
      if (keyNum >= 1 && keyNum <= 4 && phrase.clozeOptions[keyNum - 1]) {
        e.preventDefault();
        handleOptionSelect(phrase.clozeOptions[keyNum - 1]);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [
    showResult,
    isSpeaking,
    phrase.clozeOptions,
    playPhrase,
    handleOptionSelect,
  ]);

  // Reproducir autom√°ticamente cuando se muestra el resultado correcto
  useEffect(() => {
    if (showResult && isCorrect) {
      const timer = setTimeout(() => {
        speak(fullBlockText);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [showResult, isCorrect, speak, fullBlockText]);

  // Manejador para toggle de traducci√≥n con sonido
  const handleToggleTranslation = useCallback(() => {
    if (soundEnabled) {
      play('whoosh');
    }
    setShowTranslation(prev => !prev);
  }, [soundEnabled, play]);

  const correctOption = phrase.clozeOptions.find((o) => o.isCorrect);

  return (
    <div className="space-y-6">
      {/* Instrucci√≥n */}
      <div className="text-center">
        <span className="text-sm text-gray-500 dark:text-gray-400">
          {block ? "Completa la palabra faltante en el contexto" : "Completa la frase"}
        </span>
      </div>

      {/* Contexto del bloque si existe */}
      {block && (
        <motion.div
          className="bg-lf-info/10 dark:bg-lf-info/20 rounded-aaa-xl p-4 border border-lf-info/30 dark:border-lf-info/40 shadow-glass-xl backdrop-blur-aaa"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="text-xs font-semibold text-lf-info dark:text-lf-info/80 mb-2">
            {block.title}
          </div>
          <div className="text-xs text-lf-info/70 dark:text-lf-info/60">
            {block.context}
          </div>
        </motion.div>
      )}

      {/* Bloque completo con todas las frases */}
      <motion.div
        className="bg-glass-surface dark:bg-lf-soft/50 rounded-aaa-xl p-6 shadow-glass-xl backdrop-blur-aaa border border-lf-muted/20"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="space-y-3">
          {phrasesToShow.map((p) => {
            const isCurrentPhrase = p.id === phrase.id;
            const phraseText = isCurrentPhrase 
              ? textWithGap 
              : p.text;
            
            return (
              <div key={p.id} className={isCurrentPhrase ? "bg-lf-primary/10 dark:bg-lf-primary/20 rounded-lg p-3 border-2 border-lf-primary/30 dark:border-lf-primary/40" : ""}>
                <p className={`text-lg font-medium text-lf-dark dark:text-white leading-relaxed ${isCurrentPhrase ? "" : "opacity-60"}`}>
                  {phraseText.split("______").map((part, index, array) => (
                    <span key={index}>
                      {part}
                      {index < array.length - 1 && (
                        <motion.span
                          className={`
                          inline-block min-w-24 mx-1 px-3 py-1 rounded-lg font-bold
                          ${
                            showResult
                              ? isCorrect
                                ? "bg-lf-success/20 dark:bg-lf-success/30 text-lf-success dark:text-lf-success"
                                : "bg-lf-error/20 dark:bg-lf-error/30 text-lf-error dark:text-lf-error"
                              : "bg-lf-primary/20 dark:bg-lf-primary/30 text-lf-primary dark:text-lf-primary"
                          }
                        `}
                          initial={showResult && isCorrect ? { scale: 0.8 } : {}}
                          animate={showResult && isCorrect ? { scale: [0.8, 1.1, 1] } : {}}
                          transition={showResult && isCorrect ? { duration: 0.4 } : {}}
                        >
                          {showResult
                            ? isCorrect
                              ? selectedOption?.text
                              : correctOption?.text
                            : selectedOption?.text || "?"}
                        </motion.span>
                      )}
                    </span>
                  ))}
                </p>
                {!isCurrentPhrase && showTranslation && (
                  <p className="text-xs text-lf-muted dark:text-lf-muted/70 mt-1">
                      {p.translation}
                    </p>
                )}
              </div>
            );
          })}
        </div>

        {/* Bot√≥n para mostrar/ocultar traducci√≥n */}
        <div className="mt-4 flex items-center justify-center">
          <button
            onClick={handleToggleTranslation}
            className="flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all bg-lf-soft/50 dark:bg-lf-muted/30 text-lf-muted dark:text-lf-muted/80 hover:bg-lf-muted/20 dark:hover:bg-lf-muted/40 border border-lf-muted/30"
          >
            <span>{showTranslation ? "üëÅÔ∏è" : "üëÅÔ∏è‚Äçüó®Ô∏è"}</span>
            <span>
              {showTranslation ? "Ocultar traducci√≥n" : "Mostrar traducci√≥n"}
            </span>
          </button>
        </div>

        {/* Traducci√≥n del bloque completo */}
        {showTranslation && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-4 space-y-2"
          >
            {block ? (
              <div className="space-y-1">
                {block.phrases.map((p) => (
                  <p key={p.id} className="text-sm text-lf-muted dark:text-lf-muted/70">
                    <span className="font-medium">{p.text}:</span> {p.translation}
                  </p>
                ))}
              </div>
            ) : (
              <p className="text-sm text-lf-muted dark:text-lf-muted/70 text-center">
                {phrase.translation}
              </p>
            )}
          </motion.div>
        )}

        {/* Bot√≥n de audio */}
        <button
          onClick={() => speak(fullBlockText)}
          disabled={isSpeaking}
          className={`
            mt-4 px-4 py-2 rounded-lg flex items-center justify-center gap-2 transition-all mx-auto
            ${
              isSpeaking
                ? "bg-lf-primary/20 dark:bg-lf-primary/30 text-lf-primary dark:text-lf-primary"
                : "bg-lf-soft/50 dark:bg-lf-muted/30 text-lf-dark dark:text-lf-muted hover:bg-lf-muted/20 dark:hover:bg-lf-muted/40 border border-lf-muted/30"
            }
          `}
        >
          <motion.span
            animate={isSpeaking ? { scale: [1, 1.2, 1] } : {}}
            transition={{ repeat: Infinity, duration: 0.5 }}
          >
            {isSpeaking ? "üîä" : "üîà"}
          </motion.span>
          <span>{isSpeaking ? "Reproduciendo..." : block ? "Escuchar bloque completo" : "Escuchar"}</span>
        </button>
      </motion.div>

      {/* Opciones */}
      <div className="grid grid-cols-2 gap-3">
        {phrase.clozeOptions.map((option, index) => {
          const isSelected = selectedOption?.id === option.id;
          const showCorrect = showResult && option.isCorrect;
          const showIncorrect = showResult && isSelected && !option.isCorrect;

          return (
            <motion.button
              key={option.id}
              onClick={() => handleOptionSelect(option)}
              disabled={showResult}
              className={`
                p-4 rounded-aaa-xl font-medium text-center transition-all
                ${
                  showCorrect
                    ? "bg-lf-success text-white shadow-glow-success ring-4 ring-lf-success/50"
                    : showIncorrect
                    ? "bg-lf-error text-white shadow-glow-accent ring-4 ring-lf-error/50"
                    : isSelected
                    ? "bg-lf-primary text-white shadow-resonance"
                    : "bg-glass-surface dark:bg-lf-soft/50 text-lf-dark dark:text-white hover:bg-lf-primary/10 dark:hover:bg-lf-primary/20 border border-lf-muted/30"
                }
                ${showResult ? "cursor-default opacity-50" : "cursor-pointer"}
              `}
              initial={{ opacity: 0, scale: 0.9 }}
              animate={
                showCorrect
                  ? {
                      scale: [1, 1.15, 1],
                      boxShadow: [
                        "0 0 0px rgba(34, 197, 94, 0)",
                        "0 0 25px rgba(34, 197, 94, 0.6)",
                        "0 0 15px rgba(34, 197, 94, 0.4)"
                      ]
                    }
                  : showIncorrect
                  ? { x: [0, -8, 8, -8, 8, 0] }
                  : { opacity: 1, scale: 1 }
              }
              transition={showCorrect || showIncorrect ? { duration: 0.5 } : { delay: index * 0.1 }}
              whileHover={!showResult ? { scale: 1.02 } : {}}
              whileTap={!showResult ? { scale: 0.95 } : {}}
            >
              {option.text}
              {showCorrect && <span className="ml-2">‚úì</span>}
              {showIncorrect && <span className="ml-2">‚úó</span>}
            </motion.button>
          );
        })}
      </div>

      {/* Resultado */}
      <AnimatePresence>
        {showResult && (
          <motion.div
            className={`
              p-4 rounded-xl text-center shadow-glass-xl backdrop-blur-aaa
              ${
                isCorrect
                  ? "bg-lf-success/20 dark:bg-lf-success/30 text-lf-success dark:text-lf-success border border-lf-success/40"
                  : "bg-lf-error/20 dark:bg-lf-error/30 text-lf-error dark:text-lf-error border border-lf-error/40"
              }
            `}
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ type: "spring", stiffness: 300 }}
          >
            <span className="text-2xl mr-2">{isCorrect ? "üéâ" : "üí°"}</span>
            <span className="font-medium">
              {isCorrect
                ? `¬°Correcto! +${XP_RULES.clozeCorrect} XP`
                : `La respuesta correcta era: ${correctOption?.text}`}
            </span>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
